# BitMap 算法
用一个问题来引出这次的文章
> 10亿个无序整数，已知最大值为15亿，请对这10亿个数进行排序(假设无重复)。现要在32位机器上对其排列，并且内存限制为2G。

分析一下问题，10G的文件，只有2G的内存，显然不能一次性的把数据直接读进内存中直接排序。

那么，还有什么其他办法呢？这里就可以使用`BitMap`

## 什么是BitMap
所谓的BitMap就是用一个bit位来标记某个元素对应的Value，而Key即是该元素。由于采用了Bit为单位来存储数据，因此在存储空间方面，可以大大节省。

来看一个简单具体的例子，假设我们要对0-7内的5个元素(4,7,2,5,3)排序（这里假设这些元素没有重复）。那么我们就可以采用BitMap的方法来达到排序的目的。要表示8个数，我们就只需要8个Bit（1Bytes），首先我们开辟1Byte的空间，将这些空间的所有Bit位都置为0
```js
// 1 Bytes 来表示 8 为 Bit
| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
```

然后遍历这5个元素，首先第一个元素是4，那么就把4对应的位置为1，因为是从零开始的，所以要把第五位置为1：
```js
// 1 Bytes 来表示 8 为 Bit
| 0 | 0 | 0 | 0 | 1 | 0 | 0 | 0 |
```

然后处理第二个元素7，将第八位置为1,接着处理第三个元素，一直到最后处理完所有的元素，将相应的位置为1，对应状态如下
```js
// 1 Bytes 来表示 8 为 Bit
| 0 | 0 | 1 | 1 | 1 | 1 | 0 | 1 |
```
然后我们现在遍历一遍Bit区域，将该位是一的位的编号输出（2，3，4，5，7），这样就达到了排序的目的。

用简单的js代码实现以下
```js
const arr = [4,7,2,5,3]
function FindClass() {
  let bytes = new Array(100); //用来存储数据
  for( let i = 0; i < bytes.length; i++ ){ // //先初始化为0
    bytes[i] = 0;
  }
  this.addMember = function(number) { //添加
    bytes[number] = 1;
  }
  this.isExist = function(number) { //判断是否存在
    if(bytes[number] == 0){
      return false;
    } else {
      return true;
    }
  }
  this.getBytes = function(){
    return bytes;
  }
}

const findClass = new FindClass()
for (let i = 0; i< arr.length; i++) { // 把对应位置标记为1
  findClass.addMember(arr[i] + 1)
}
const bytes = findClass.getBytes()
let result = []
for (let i = 0; i< bytes.length; i++) {
  if (bytes[i] === 1) {
    result.push(i + 1)
  }
}
console.log(result) // [2,3,4,5,7]
```

那么如果扩充到一亿个整数排序呢，一个整数算作4个字节，4亿个字节大概需要占用380M的内存空间

想象一下有8个路灯,编号从1-8,其中2,5,7,8是亮的,其余不亮.

如果二进制来表示，且用1代表亮，0代表不亮，那么这个二进制表现为`01001011`

1个整数有4个Bytes, 也就是32Bit,就可以代表32盏灯

改造一下上面的isExit方法

设一个`value`，其初始化为0

当 add() 传进来参数是`0`的时候, 就把`value`的第1位设置为`1`, 如下所示
> 00000000 00000000 00000000 00000001 
此时`value`的值为 1

再加 3, 把`value`的第4位设置为`1`
> 00000000 00000000 00000000 00001001 
此时 `value`的值为 9 ,9就表示0和3都存在 

可以得出结论, 32bit 可以判断`0-31`是否存在

如果创建一个大小为10的数组,数组里存储整数,那么这个数组就可以表示代表`0-319`是否存在
- bytes[0] 表示0-31是否存在
- bytes[1] 表示32-63是否存在
- ....
- bytes[9] 表示288-319是否存在

**通过这种方式,可以把空间的使用降低为原来的`1/32`**

存储一个亿数据的存在状态,就只需要10M+的空间

## 位运算
这种方式涉及到了位运算,简单了解下:
### 按位与 &
规则: 两个整数进行&与运算,相同二进制的数字如果都是1, 则结果为1,有一个为0,则为0
- 1 & 1 = 1
- 1 & 0 = 0
 -0 & 0 = 0

### 按位或 |
规则: 两个整数进行|或运算,相同二进制的数字如果有一个为1, 则结果为1,都是0,则为0
- 1 | 1 = 1
- 1 | 0 = 1 
- 0 | 0 = 0

### 左移 << 
规则: 二进制向左移动n位, 在后面添加n个0 
- 3<<1 = 0011 -> 0110, 得到了 6
- 3<<2 = 0011 -> 1100, 得到了 12

## 实现
按照上面的思路,重新设计一个查找类, 实现`addMember`和`isExist`方法，用更快的速度，更少的内存
### addMember
`0-100`只需要4个整数, 4 * 32 > 100 来表示是否存在,创建一个大小为4的数组

思路: 
- 先用`member/32`,确定`member`在数组里的索引`arr_index`,比如`33`就存在`arr[1]`中
- 然后用`member%32`，确定在整数的哪个二进制位进行操作`bit_index`, 比如`33`就存在 `arr[1]` 的下标为`1`的bit上
- 最后执行`bit_arr[arr_index] = bit_arr[arr_index] | 1<<bit_index`用来对应的bit进行赋值
```js
this.addMember = function(member) {
  // 决定在数组中的索引
  var arr_index = Math.floor(member / 32) 
  // 决定在整数的32个bit位的哪一位上
  var bit_index = member % 32 
  // 对应的bit进行赋值
  bit_arr[arr_index] = bit_arr[arr_index] | 1 << bit_index
  //                 00000000 00000000 00000000 00000000 | 1 << 1
  // 1 << 1 相当于    00000001 << 1 -> 00000010
  // 所以上面计算得到   00000000 00000000 00000000 00000010
}
```

### isExist
思路
- 先用`member/32`,确定`member`在数组里的索引`arr_index`
- 然后用`member%32`,确定在整数的哪个二进制位进行操作`bit_index`
- 最后执行`bit_arr[arr_index] & 1<<bit_index`,如果结果为`1`,就说明`member`存在
```js
this.isExist = function(member){
  // 决定在数组中的索引
  var arr_index = Math.floor(member/32) 
  // 决定在整数的32个bit位的哪一位上
  var bit_index = member % 32 
  var value = bit_arr[arr_index] & 1 << bit_index
  return value === 1
}
```

这种数据结构基于位做映射，能够用很少的内存存储数据，和数组不同，它只能存储表示某个数是否存在，可以用于大数据去重，大数据排序，两个集合取交集。

BitMap在处理大数据时才有优势，而且要求数据集紧凑，如果要处理的数只有3个：1，1000，100000，那么空间利用率太低了，最大的值决定了BitMap要用多少内存。

## 大数据排序
拿出一开始提到的问题

BitMap存储最大值为15亿的集合，只需要180M 的空间，空间使用完全可以接受，

至于速度，存储和比较过程中的位运算速度都非常快，第一次遍历，将10亿个数都放入到BitMap中，

第二次，从0到15亿进行遍历，如果在BitMap，则输出该数值，这样经过两次遍历，就可以将如此多的数据排序。

### 再来一个问题
在2.5亿个整数中找出不重复的整数，注，内存不足以容纳这2.5亿个整数

采用2-Bitmap（每个数分配2bit，00表示不存在，01表示出现一次，10表示多次，11无意义）

共需内存`2^32 * 2 bit`=`1GB`内存

然后扫描这2.5亿个整数，查看Bitmap中相对应位,如果是00变01，01变10，10保持不变。

所描完事后，查看bitmap，把对应位是01的整数输出即可。

## 扩展阅读(布隆过滤器)
前面所讲的BitMap的确很厉害，可以，却有着很强的局限性，BitMap只能用来处理整数，无法处理字符串，假设让你写一个强大的爬虫，每天爬取数以亿计的网页，那么你就需要一种数据结构，能够存储你已经爬取过的 url ，这样，才不至于重复爬取。

你可能会想到使用hash函数对url进行处理，转成整数，这样，似乎又可以使用BitMap了，但这样还是会有问题。假设BitMap能够映射的最大值是 M ，一个url的hash值需要对M求模，这样，就会产生冲突，而且随着存储数据的增多，冲突率会越来越大。

布隆过滤器的思想非常简单，其基本思路和BitMap是一样的，可以把布隆过滤器看做是 BitMap的扩展。为了解决冲突率，布隆过滤器要求使用k个 hash函数，新增一个 key时，把 key散列成 k 个整数，然后在数组中将这 k 个整数所对应的二进制位设置为1，判断某个key是否存在时，还是使用 k 个hash函数对key进行散列，得到k个整数，如果这k个整数所对应的二进制位都是1，就说明这个key存在，否则，这个key不存在。

推荐链接

[大数据量处理利器：布隆过滤器](https://yq.aliyun.com/articles/3607)

[javascript实现布隆过滤器](https://blog.csdn.net/liebert/article/details/79737042)

## 参考
[https://www.e-learn.cn/topic/1619491](https://www.e-learn.cn/topic/1619491)
[https://blog.xhu.me/post/JS%20%E5%AE%9E%E7%8E%B0%20BitMap%20%E6%9F%A5%E8%AF%A2%E7%AE%97%E6%B3%95](https://blog.xhu.me/post/JS%20%E5%AE%9E%E7%8E%B0%20BitMap%20%E6%9F%A5%E8%AF%A2%E7%AE%97%E6%B3%95)